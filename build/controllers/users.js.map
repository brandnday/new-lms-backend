{"version":3,"sources":["../../src/controllers/users.js"],"names":["bcrypt","jwt","pgPool","decodeToken","exec","ctx","res","query","ok","hashpassword","password","next","hashedPassword","Promise","resolve","reject","genSalt","err","salt","hash","tokenOfUser","user","privKey","timestamp","Date","getTime","sign","iat","getUser","username","rows","signin","request","body","response","success","token","signup","hpass","test","checkAuthorize","role","authoken","headers","payload","roles","SADMIN","ADMIN","OPERATOR","timestampNow","isTimeout","haveToRefreshToken","therole","authorized","includes","timeout"],"mappings":"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","file":"users.js","sourcesContent":["import bcrypt from \"bcrypt-nodejs\";\nimport jwt from \"jsonwebtoken\";\nimport { pgPool } from \"../services/database\";\nimport { decodeToken } from \"../services/token\";\n\nexport const exec = async ctx => {\n  const res = await pgPool.query(`insert into testyea values(3,'andreas2')`);\n  ctx.ok({ res });\n};\n\nconst hashpassword = async (password, next) => {\n  const hashedPassword = await new Promise((resolve, reject) => {\n    bcrypt.genSalt(10, (err, salt) => {\n      if (err) return next(err);\n      bcrypt.hash(password, salt, null, (err, hash) => {\n        if (err) return next(err);\n        resolve(hash);\n      });\n    });\n  });\n  return hashedPassword;\n};\n\nexport const tokenOfUser = user => {\n  const privKey = \"qwerasdfqwerqwer12341sfasdfasdgcvbxclgsjldkfjasdf\";\n  const timestamp = new Date().getTime() + 7200000;\n  return jwt.sign({ user, iat: timestamp }, privKey);\n};\n\nconst getUser = async username => {\n  const res = await pgPool.query(\n    `select id, username,role from truser where username = $1`,\n    [username]\n  );\n  return res.rows[0];\n};\n\nexport const signin = async (ctx, next) => {\n  const { username } = ctx.request.body;\n  const user = await getUser(username);\n  ctx.ok({ response: { success: true, token: tokenOfUser(user) } });\n};\n\nexport const signup = async (ctx, next) => {\n  const { username, password } = ctx.request.body;\n  const hpass = await hashpassword(password, next);\n  await pgPool.query(\n    `insert into usersyea(username,password) values('${username}','${hpass}')`\n  );\n  ctx.ok({ test: \"asdf\" });\n};\n\nexport const checkAuthorize = async (ctx, next) => {\n  const { role } = ctx.request.body;\n  const { authoken } = ctx.request.headers;\n  const { payload } = decodeToken(authoken);\n  const username = payload.user.username;\n  const roles = {\n    SADMIN: [\"SADMIN\"],\n    ADMIN: [\"SADMIN\", \"ADMIN\"],\n    OPERATOR: [\"SADMIN\", \"ADMIN\", \"OPERATOR\"]\n  };\n  const user = await getUser(username);\n  const timestampNow = new Date().getTime();\n  const isTimeout = timestampNow > payload.iat;\n  const haveToRefreshToken = timestampNow > payload.iat - 3600000;\n  const token = isTimeout || !haveToRefreshToken ? false : tokenOfUser(user);\n  const therole = user.role;\n  const authorized = roles[role].includes(therole);\n  ctx.ok({\n    response: {\n      authorized: authorized,\n      role: therole,\n      timeout: isTimeout,\n      token,\n      haveToRefreshToken\n    }\n  });\n};\n"]}